<!-- 

namespace App\Security;

use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\CustomUserMessageAuthenticationException;
use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport; -->

/**
 * @see https://symfony.com/doc/current/security/custom_authenticator.html
 */
class SecurityAuthenticator extends AbstractAuthenticator
{
    /**
     * Called on every request to decide if this authenticator should be
     * used for the request. Returning `false` will cause this authenticator
     * to be skipped.
     */
    public function supports(Request $request): ?bool
    {
        // return $request->headers->has('X-AUTH-TOKEN');
    }

    public function authenticate(Request $request): Passport
    {
        // $apiToken = $request->headers->get('X-AUTH-TOKEN');
        // if (null === $apiToken) {
        // The token header was empty, authentication fails with HTTP Status
        // Code 401 "Unauthorized"
        // throw new CustomUserMessageAuthenticationException('No API token provided');
        // }

        // implement your own logic to get the user identifier from `$apiToken`
        // e.g. by looking up a user in the database using its API key
        // $userIdentifier = /** ... */;

        // return new SelfValidatingPassport(new UserBadge($userIdentifier));
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        // on success, let the request continue
        return null;
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
    {
        $data = [
            // you may want to customize or obfuscate the message first
            'message' => strtr($exception->getMessageKey(), $exception->getMessageData()),

            // or to translate this message
            // $this->translator->trans($exception->getMessageKey(), $exception->getMessageData())
        ];

        return new JsonResponse($data, Response::HTTP_UNAUTHORIZED);
    }

    // public function start(Request $request, AuthenticationException $authException = null): Response
    // {
    //     /*
    //      * If you would like this class to control what happens when an anonymous user accesses a
    //      * protected page (e.g. redirect to /login), uncomment this method and make this class
    //      * implement Symfony\Component\Security\Http\EntryPoint\AuthenticationEntryPointInterface.
    //      *
    //      * For more details, see https://symfony.com/doc/current/security/experimental_authenticators.html#configuring-the-authentication-entry-point
    //      */
    // }
}


//

namespace App\Security;

use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Http\Authenticator\AbstractAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\Authenticator\Passport\SelfValidatingPassport;

class SecurityAuthenticator extends AbstractAuthenticator
{

    public function supports(Request $request): ?bool
    {
        return $request->headers->has('Authorization') && str_contains($request->headers->get('Authorization'), 'Bearer ');
    }

    public function authenticate(Request $request): Passport
    {
        $identifier = str_replace('Bearer ', '', $request->headers->get('Authorization'));
        return new SelfValidatingPassport(
            new UserBadge($identifier)
        );
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        return null;
    }

    public function onAuthenticationFailure(Request $request, AuthenticationException $exception): ?Response
    {
        return new JsonResponse([
            'message' => $exception->getMessage()
        ], Response::HTTP_UNAUTHORIZED);
    }
}

//authenticator


namespace App\Security;

use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Componenpt\HttpFoundation\Response;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Http\Authenticator\AbstractLoginFormAuthenticator;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\CsrfTokenBadge;
use Symfony\Component\Security\Htt\Authenticator\Passport\Badge\RememberMeBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Badge\UserBadge;
use Symfony\Component\Security\Http\Authenticator\Passport\Credentials\PasswordCredentials;
use Symfony\Component\Security\Http\Authenticator\Passport\Passport;
use Symfony\Component\Security\Http\SecurityRequestAttributes;
use Symfony\Component\Security\Http\Util\TargetPathTrait;

class SecurityAuthenticator extends AbstractLoginFormAuthenticator
{
    use TargetPathTrait;

    public const LOGIN_ROUTE = 'app_login';

    public function __construct(private UrlGeneratorInterface $urlGenerator)
    {
    }

    public function authenticate(Request $request): Passport
    {
        $email = $request->request->get('email', '');

        $request->getSession()->set(SecurityRequestAttributes::LAST_USERNAME, $email);

        

        return new Passport(
            new UserBadge($email),
            new PasswordCredentials($request->request->get('password', '')),
            [
                new CsrfTokenBadge('authenticate', $request->request->get('_csrf_token')),
                new RememberMeBadge(),
            ]

        );
    }

    public function onAuthenticationSuccess(Request $request, TokenInterface $token, string $firewallName): ?Response
    {
        if ($targetPath = $this->getTargetPath($request->getSession(), $firewallName)) {
            return new RedirectResponse($targetPath);
            
        }

        // For example:
        return new RedirectResponse($this->urlGenerator->generate('app_admin_dashboard_index'));

        
    }

    protected function getLoginUrl(Request $request): string
    {
        return $this->urlGenerator->generate(self::LOGIN_ROUTE);
    }
}

//terms************************

{% extends 'base.html.twig' %}

{% block title %} {{ 'Termes et conditions' }} {% endblock %}

{% block body %}
	<!-- <div class="container-fluid bg-light py-5">
		<div class="container py-5">
		{% for term in terms|sort((a, b) => a.id <=> b.id) %}
			<div class="row g-4">
				<div class="col-lg-6">
					<div class="mb-4">
						<h5>Siège social</h5>
						<p>Nom de l’entreprise: <strong>Black Dog Éducation</strong></p>
					</div>
					<p class="my-4">Représenté par: Antonin BOUCHERIE</p>
					<p class="my-4">Adresse: 47 Bis rue Bremaudière Niort 79000</p> 
					{# <p class="my-4">{{ terms.content }}</p> #}
					<div class="mb-4">
						<h5>Contact</h5>
					</div>
					<p class="my-4  ">{{ term.summury }}</p> 
					{# <p class="my-4">E-Mail : blackdog.educ@gmail.com</p> #}
					<div class="mb-4">
						<h5>Représentant légal</h5>
					</div>
					<p class="my-4">Inscription au registre du commerce et des sociétés</p>
					<p class="my-4">{{ term.title }}</p> 
				{% endfor %}
				</div>
				<div class="col-lg-6" style="min-height: 200px;">
					<div class="position-relative d-flex justify-content-center align-items-center h-100">
						<img class="img-fluid w-50 h-auto" src="{{ asset('assets/image/black-dog-educ1.jpg') }}" style="object-fit: cover;">
					</div>
				</div>
			</div>
            <div class="row my-4 g-4">
				<div class="col-lg-6">
					<div class="mb-4">
						<h2>Condition Générales de Vente.</h2>
					</div>

					<h5>Article 1 : Préambule.</h5>
					<p class="my-4">Le présent contrat a pour <strong>objet</strong> de <strong>définir</strong> les droits et obligations de <strong>l'éducateur canin</strong> et comportementaliste<strong> Antonin BOUCHERIE (ci-après dénommé « L'éducateur »)</strong> et de la personne physique ou morale <strong>qui utilise</strong> ses services <strong>(ci-après dénommé « le client »).</strong> 
                    En <strong>effectuant une réservation</strong> et en <strong>payant</strong> la prestation, le client déclare <strong>son acceptation</strong> sans réserve <strong>des</strong> termes <strong>et conditions</strong> de <strong>cette prestation</strong> ainsi que de <strong>l'ensemble</strong> des <strong>conditions générales</strong> de vente. <strong>Elles remplacent</strong> toutes autres conditions générales ou particulières non expressément agréées par le Vendeur. 
                    Le Vendeur se réserve <strong>le droit</strong> de modifier <strong>les</strong> Conditions <strong>Générales</strong> de Vente à tout moment <strong>et</strong> sans <strong>préavis</strong>. Les conditions <strong>générales</strong> en vigueur au <strong>moment de</strong> la <strong>réservation</strong> ou <strong>du paiement</strong> par le <strong>client s'appliquent. Les CGV seront mise</strong> à disposition du client sur simple demande.
					</p>

                    <h5 class="my-4">Article 2 : Domaine d’intervention et nature des prestations.</h5>
					<p class="my-4">Antonin BOUCHERIE (nom commercial Black Dog Education) est une entreprise <strong>exonerée de TVA au</strong> statut <strong>d'entreprise indépendante</strong> et propose les services suivants :</p>
                    <p class="my-4"><strong>Les cours d'éducation</strong> et de réeducation canine <strong>au</strong> domicile du <strong>client,</strong> en extérieur et <strong>cours de dressage</strong> individuel <strong>et promenades collectives</strong> encadrées. </p>
                    <p class="my-4"><strong>Les prix sont indiqués</strong> sur le site <strong>Internet</strong> www.black-dog-education.fr.</p>

					<h5 class="my-4">Article 3 : Obligations du l'Educateur.</h5>
					<p class="my-4">Le client doit prendre en compte qu'un travail personnel doit être fourni par lui pour aboutir au résultat demandé par l'éducateur.</p>
                    <p class="my-4">L'educateur se doit de fournir une méthode et des conseils réalisables pour le client, mais l'éducation est un travail à faire conjointement entre l'éducateur et le client.</p>
				
					
                    <h5 class="my-4">Article 4 : Obligations du Client.</h5>
					<p class="my-4">Le Client est défini comme étant la personne ayant contacté Antonin BOUCHERIE (Black Dog Education) lors du rendez-vous en présentiel ou en ligne.</p>
                    <p class="my-4">Le client s’engage à mettre à disposition de Black Dog Education tous les moyens nécessaires pour la réalisation des prestations définies.</p>
                    <p class="my-4">Le client est conscient que son travail personnel est garant du succès mis en place par Black Dog Education et que ce dernier ne saurait être tenu pour responsable de l’échec du processus.</p>

                    <h5 class="my-4">Article 5: Responsabilité du client.</h5>
					<p class="my-4">La responsabilité du client est un élément crucial dans le contexte de Black Dog Education. L'éducateur ne peut être tenu responsable en cas de morsure. 
                    Il est essentiel que les clients comprennent que leur implication est nécessaire pour assurer la sécurité de tous les participants: en suivant les consignes de l'éducateur, en fournissant des informations précises sur le comportement du chien et en respectant les règles de sécurité. Les clients contribuent activement à la prévention des incidents. 
                    La responsabilité client est donc primordiale pour créer un environnement d'apprentissage sûr et positif.</p>
                    <p class="my-4">Le Client sera responsable des dommages causés par son chien, sur lui-même ou sur autrui.</p>

                    <h5 class="my-4">Article 6 : Modalités de paiement</h5>
                    <p class="my-4">Le Vendeur accepte le paiement en espèces, chèques et carte de crédit.</p>

                    <h5 class="my-4">Article 7 : Confidentialité</h5>
                    <p class="my-4">La confidentialité est une valeur importante chez Black Dog Education: nous nous engageons à protéger les informations personnelles de nos utilisateurs. 
                    Toutes les données collectées sont traitées de manière confidentielle et ne sont utilisées que dans le but d'améliorer nos services éducatifs.</p>
                    <p class="my-4">Cela signifie également respecter les délais fixés, en faisant preuve de discipline et de motivation le client maximise ses chances de réussite et tire pleinement parti de l'expérience d'apprentissage offerte par Black Dog Education.</p>
				</div>
				<div class="col-lg-6" style="min-height: 200px;">
					<div class="position-relative d-flex justify-content-center align-items-center h-100">
						<img class="img-fluid w-50 h-auto" src="{{ asset('assets/image/blac-dog-educ6.jpg') }}" style="object-fit: cover;">
					</div>
				</div>
			</div>
        {# {% endfor %} #}
		</div>
	</div> -->

{% endblock %}

api youtube***********************

<!-- $apikey = "AIzaSyBvZxd4QS7wn0D_YTWelF0XQQADlz9lPBE";
					$channelid = "";
					$url = "https://www.googleapis.com/youtube/v3/search?key=$apikey&channelId&part=snippet,id&maxResults=1";

					$response = file_get_contents($url);
					$data = json_decode($response);

					foreach($data->items as $item){
						$videoId = $item->id->videoId;
						$videoId = $item->snippet->title;
						$videoThmbnail = $item->snippet->thumbnails->default->url;

						echo "<h2>$videoTitle</h2>";
						echo "<iframe width='600' style='aspect-ratio' src="https://www.youtube.com/embed/$videoId" frameborder="0" allowfullscreen></iframe>";
					} -->


                    // namespace App\Controller;

// use App\Entity\ContactForm;
// use App\Form\ContactFormType;
// use Symfony\Component\Mime\Address;
// use Doctrine\ORM\EntityManagerInterface;
// use Symfony\Bridge\Twig\Mime\TemplatedEmail;
// use Symfony\Component\HttpFoundation\Request;
// use Symfony\Component\Mailer\MailerInterface;
// use Symfony\Component\HttpFoundation\Response;
// use Symfony\Component\Routing\Attribute\Route;
// use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
// use Symfony\Contracts\HttpClient\Exception\TransportExceptionInterface;


// class IndexController extends AbstractController
// {
//     private MailerInterface $mailer;

//     private EntityManagerInterface $entityManager;
//     public function __construct(MailerInterface $mailer, EntityManagerInterface $entityManager){
//         $this->mailer = $mailer;
//         $this->entityManager = $entityManager;
//     }
//     #[Route('/', name: 'app_index',)]
//     public function index(Request $request): Response
//     {
//         $contactForm = new ContactForm();
//         $form = $this ->createForm(ContactFormType::class, $contactForm);
//         $form->handleRequest($request);


//         if ($form->isSubmitted()) {
//             if ($form->isValid()) {
//                 $subject = $form->get('subject')->getData() ?: 'No subject';

//                 $this->entityManager->persist($contactForm);
//                 $this->entityManager->flush();

//                 $email = (new TemplatedEmail())
//                     ->from($form->get('email')->getData())
//                     ->to(new Address('blackdog.educ@gmail.com', 'BLACK DOG EDUCATION'))
//                     ->subject($subject)
//                     ->htmlTemplate('emails/contact.html.twig')
//                     ->context([
//                         'name' => $form->get('name')->getData(),
//                         'number' => $form->get('number')->getData(),
//                         'message' => $form->get('message')->getData(),
//                         'subject' => $subject,
//                         'mail' => $form->get('email')->getData(),
//                     ]);

//                 try {
//                     $this->mailer->send($email);
//                     $this->addFlash('success', 'Votre email a été envoyé');
//                     return $this->redirectToRoute('app_index');
//                 } catch (TransportExceptionInterface $e) {
//                     $this->addFlash('error', 'Une erreur est survenue lors de l\'envoi de l\'email');
//                 }
//             } else {
//                 $this->addFlash('error', 'Il y a des erreurs dans votre formulaire. Veuillez les corriger.');
//             }
//         }
            
//         return $this->render('index/index.html.twig', [
//             'form' => $form ->createView(),
            
//         ]);
  
//     }
    
// private function getYoutubeVideos(): array
//     {
//         $apikey = "AIzaSyBvZxd4QS7wn0D_YTWelF0XQQADlz9lPBE";
//         $channelid = "UC3QJMQuEVuw5jkymShoOaUg";
//         $url = "https://www.googleapis.com/youtube/v3/search?key=$apikey&channelId=$channelid&part=snippet,id&maxResults=1&type=video";

//         $response = @file_get_contents($url);
//         if ($response === false) {
//             return [];
//         }

//         $data = json_decode($response);
//         $videos = [];

//         foreach ($data->items as $item) {
//             if (isset($item->id->kind) && $item->id->kind === 'youtube#video' && isset($item->id->videoId)) {
//                 $videos[] = [
//                     'videoId' => $item->id->videoId,
//                     'title' => $item->snippet->title ?? 'Titre non disponible',
//                     'thumbnail' => $item->snippet->thumbnails->medium->url ?? null
//                 ];
//             }
//         }

//         return $videos;
//     }
//}







// private function getYoutubeVideos(): array
//     {
//         $apikey = "AIzaSyBvZxd4QS7wn0D_YTWelF0XQQADlz9lPBE";
//         $channelid = "UC3QJMQuEVuw5jkymShoOaUg";
//         $url = "https://www.googleapis.com/youtube/v3/search?key=$apikey&channelId=$channelid&part=snippet,id&maxResults=1&type=video";

//         $response = @file_get_contents($url);
//         if ($response === false) {
//             return [];
//         }

//         $data = json_decode($response);
//         $videos = [];

//         foreach ($data->items as $item) {
//             if (isset($item->id->kind) && $item->id->kind === 'youtube#video' && isset($item->id->videoId)) {
//                 $videos[] = [
//                     'videoId' => $item->id->videoId,
//                     'title' => $item->snippet->title ?? 'Titre non disponible',
//                     'thumbnail' => $item->snippet->thumbnails->medium->url ?? null
//                 ];
//             }
//         }

//         return $videos;
//     }